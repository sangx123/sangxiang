1,蓝牙连接
先判断蓝牙是否可用mBluetoothAdapter可用
//获取蓝牙设备
BluetoothAdapter.getDefaultAdapter()
				.getRemoteDevice(address);
//绑定蓝牙
ClsUtils工具类
//开始连接蓝牙
device.connectGatt(context, false, mGattCallback);
2,蓝牙连接成功之后的回调
private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {

		@Override
		public void onConnectionStateChange(BluetoothGatt gatt, int status,
				int newState) {
			String intentAction;
			if (newState == BluetoothProfile.STATE_CONNECTED) {
				mConnectionState = STATE_CONNECTED;
				if (mBluetoothGatt.discoverServices()) {
				}
			} else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
				mConnectionState = STATE_DISCONNECTED;
				if (mBluetoothGatt != null) {
					mBluetoothGatt.close();
					mBluetoothGatt = null;
				}
			}
		}
蓝牙连接成功之后服务查找
@Override
		public void onServicesDiscovered(BluetoothGatt gatt, int status) {
			if (status == BluetoothGatt.GATT_SUCCESS) {
				// scale
				mBluetoothGattService = gatt.getService(UUID
						.fromString("0000fff0-0000-1000-8000-00805f9b34fb"));
				if (mBluetoothGattService != null) {
					// 使能通知fff2
					EnableFFF2();
				}

			}
		}
  蓝牙使能通知fff2
  private void EnableFFF2() {
		BluetoothGattCharacteristic characteristic;
		characteristic = mBluetoothGattService
				.getCharacteristic(UUID_AIR_DATA_F2);
		boolean enabled = true;
		if (characteristic != null) {
			mBluetoothGatt.setCharacteristicNotification(characteristic,
					enabled);

			List<BluetoothGattDescriptor> descriptorl = characteristic
					.getDescriptors();
			descriptor = descriptorl.get(0);
			if (descriptor != null) {
				descriptor
						.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
				mBluetoothGatt.writeDescriptor(descriptor);
			}
		}
    
    @Override
		public void onCharacteristicRead(BluetoothGatt gatt,
				BluetoothGattCharacteristic characteristic, int status) {
			if (status == BluetoothGatt.GATT_SUCCESS) {

			}
		}

		@Override
		public void onCharacteristicChanged(BluetoothGatt gatt,
				BluetoothGattCharacteristic characteristic) {
			if (UUID_AIR_DATA_F2.equals(characteristic.getUuid())) {
				byte[] data = characteristic.getValue();
				// FFF2在得到数据之后,调用该方法解析

				parser.getArray(data, data.length);
				Log.e("GET", Converter.byteArrayToHexString(data));
                Intent intent = new Intent("mil.bt");
                intent.putExtra("cmd", 11);
                sendBroadcast(intent);
			}
		}

		@Override
		public void onCharacteristicWrite(BluetoothGatt gatt,
				BluetoothGattCharacteristic characteristic, int status) {
			// TODO Auto-generated method stub
			Log.e("SEND:",
					Converter.byteArrayToHexString(characteristic.getValue()));
			if (UUID_AIR_DATA_F1.equals(characteristic.getUuid())) {
				// *******回调中一定调用下面方法用于分段发送*******
				outStream.ContinueSend();
			}
			super.onCharacteristicWrite(gatt, characteristic, status);

		}

		@Override
		public void onDescriptorWrite(BluetoothGatt gatt,
				BluetoothGattDescriptor descriptor, int status) {
			// TODO Auto-generated method stub
			// 使能fff2之后实例化写通道
            Mlog.e("蓝牙服务绑定完成");
			BluetoothGattCharacteristic characteristic2 = mBluetoothGattService
					.getCharacteristic(UUID_AIR_DATA_F1);
			outStream = new LEOutPutStream(mBluetoothGatt, characteristic2,
					false);
			parser = new Parser(outStream, AirBLEService.this, address);
            //// TODO: 3/12/15  不需要

            Intent intent = new Intent("mil.bt");
			intent.putExtra("cmd", 1);
			sendBroadcast(intent);
            if(telCallBack!=null){
                telCallBack.call();
            }
            if(smCallBack!=null){
                smCallBack.call();
            }

            super.onDescriptorWrite(gatt, descriptor, status);
		}

